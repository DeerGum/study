# Web개발에서 자바 진영의 역사
- EJB(Enterprise JavaBeans)를 표준으로 사용해서 개발
    - 어렵고 복잡하고 느림
    - 비용도 비쌈
    - ORM으로 EJB 엔티티빈을 사용
- 복잡하고 프레임워크 종속적인 EJB에 반하는 개념으로 순수 자바 객체 (POJO)라는 용어가 나옴
- 2002년 로드 존슨이라는 개발자가 EJB의 문제점을 지적하면서 `J2EE Design and Development`라는 책을 냄
    - 이 책에서는 EJB 없이도 충분히 고품질의 확장 가능한 애플리케이션을 개발할 수 있음을 보여줌
    - 이 책에 지금의 스프링 핵심 개념과 기반 코드가 들어 있음
    - BeanFactory, ApplicationContext, POJO(Plain Old Java Object), 제어의 역전, 의존관계 주입
- 책 출간 후 유겐 휠러, 얀 카로프가 로드 존슨에게 오픈소스 프로젝트를 제안
- 스프링 이름은 전통적인 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 지음

# Spring
- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술 : 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 언어 : 코틀린, 그루비
- 최근엔 스프링 부트를 통해서 편리하게 사용

# Spring boot
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd party 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

# Spring의 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

# 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
- 클린코드의 저자 로버트 마틴이 정리한 5원칙
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
    - 한 클래스는 하나의 책임만 가져야 한다.
    - 중요한 기준은 `변경`, 변경이 있을 때 파급 효과가 적으면 SRP원칙을 잘 따른 것
2. OCP(Open/Closed Principle) : 개방-폐쇄 원칙
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    - 다형성 활용(단 다형성만 사용해선 원칙 지킬 수 없음)
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요함
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요 (ex - 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라고 앞으로 가야함)
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
5. DIP(Dependency Inversion Principle) : 의존관계 역전 원칙
    - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나
    - 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻
- 다형성만 갖고 OCP와 DIP를 지킬 수 없음 뭔가 더 필요

# 스프링과 객체 지향
- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
    - DI(Dependency Injection) : 의존관계, 의존성 주입
    - DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 확장 가능
- 이상적으로는 모든 설계에 인터페이스를 부여하자
    - 하지만 인터페이스는 추상화라는 비용이 발생
    - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향 후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법

# IoC, DI, 컨테이너
## 제어의 역전 IoC(Inversion of Control)
- 기존의 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행함, 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종, 개발자 입장에서는 자연스러운 흐름임
- 예제 코드에서 프로그램에 대한 제어 흐름을 모두 `AppConfig`에서 갖고 있는데 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라고 함

## 프레임워크 vs 라이브러리
- 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크(프레임워크가 지정한 규칙에 따라서 코드를 작성하면)
- 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리(라이브러리의 클래스나 메소드를 내 입맞에 맞춰서 가져다 사용하면)

## 의존관계 주입 DI(Dependency Injection)
- 의존관계는 `정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체 의존 관계` 둘을 분리해서 생각해야 함
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있음
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있음

## IoC 컨테이너, DI 컨테이너
- `AppConfig`처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 `DI 컨테이너`라고 함 (또는 어셈블러, 오브젝트 팩토리 등으로 불림)

## 스프링 컨테이너
- `ApplicationContext`를 스프링 컨테이너라 한다.
- 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig`를 설정정보로 사용한다. 여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었음
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록함
    - 빈 이름은 항상 다른 이름을 부여해야함, 같은 이름으로 부여하면 다른 빈이 무시되거나 기본 빈을 덮어버리는 등 설정에 따라 오류가 발생
- 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입함

## 스프링 빈 조회 - 상속관계
- 부모 타입으로 조회하면 자식 타입도 함께 조회함
- 그래서 `Object` 타입으로 조회하면 모든 스프링 빈을 조회함

## BeanFactory와 ApplicationContext
![image](https://user-images.githubusercontent.com/47655983/165941948-b6f6d947-1dba-489b-8f80-d72b328ea0a8.png)

- BeanFactory
    - 스프링 컨테이너의 최상위 인터페이스
    - 스프링 빈을 관리하고 조회하는 역할을 담당
    - `getBean()`을 제공함
- ApplicationContext
    - BeanFactory 기능을 모두 상속받아서 제공
    - 애플리케이션을 개발할 때는 빈을 관리하고 조회하는 기능은 물론이고 수 많은 부가기능이 필요
- ApplicationConext가 제공하는 부가기능
![image](https://user-images.githubusercontent.com/47655983/165942516-c13e9b2c-c950-47ad-b468-57c634ecba01.png)
    - 메시지소스를 활용한 국제화 기능
        - 예를 들어 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
    - 환경변수
        - 로컬, 개발, 운영등을 구분해서 처리
    - 애플리케이션 이벤트
        - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
    - 편리한 리소스 조회
        - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
- 정리
    - ApplicationContext는 BeanFactory의 기능을 상속받음
    - ApplicationCOntext는 빈 관리기능 + 편리한 부가 기능을 제공
    - BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용
    - BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다
    
## 다양한 설정 형식 지원 - 자바 코드, XML
- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다.
    - 자바 코드, XML, Groovy 등등

![image](https://user-images.githubusercontent.com/47655983/165943872-f098af38-070c-4148-867c-4ff6220062a1.png)

### 어노테이션 기반 자바 코드 설정 사용
- 많이 사용하는 설정
- `new AnnotationConfigApplicationContext(AppConfig.class)`
- `AnnotationConfigApplicationContext`클래스를 사용하면서 자바 코드로 된 설정 정보를 넘기면 된다.

### XML 설정 사용
- 최근에는 스프링 부트를 많이 사용하면서 XML기반의 설정은 잘 사용하지 않는다. 아직 많은 레거시 프로젝트들이 XML로 되어 있고, 또 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있으므로 한번쯤 배워두면 좋다.
- `GenericXmlApplicationContext`를 사용하면서 `xml`설정 파일을 넘기면 된다.

## 스프링 빈 설정 메타 정보 - BeanDefinition
- 스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까 -> `BeanDefinition`이라는 추상화 덕분
- 간단히 말하면 `역할과 구현을 개념적으로 나눈 것`
    - XML을 읽어서 BeanDefinition을 만들면 된다.
    - 자바 코드를 읽어서 BeanDefinition을 만들면 된다.
    - 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 된다. 오직 BeanDefinition만 알면 된다.
- `BeanDefinition`을 빈 설정 메타정보라 한다.
    - `@Bean`, `<bean>`당 각각 하나씩 메타 정보가 생성
- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성
- 정리
    - BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수도 있다. 하지만 실무에서 직접 정의하거나 사용할 일은 거의 없다.
    - BeanDefinition에 대해서는 너무 깊이있게 이해하기 보다는 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하면 된다.